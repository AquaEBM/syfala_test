//! Common queue-related utilities used throughout the protocol implementation.
//!
//! This module provides small helpers and adapters for working with ring
//! buffers, and periodic wake-up logic.
use core::{num, iter};

pub use rtrb;

pub trait Counter {
    fn advance(&mut self, delta: usize);
    fn current(&self) -> u64;
}

impl<'a, T: Counter> Counter for &'a mut T {
    #[inline(always)]
    fn advance(&mut self, delta: usize) {
        (**self).advance(delta);
    }

    #[inline(always)]
    fn current(&self) -> u64 {
        (**self).current()
    }
}

#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GenericCounter(u64);

impl GenericCounter {
    #[inline(always)]
    pub const fn new() -> Self {
        Self(0)
    }
}

impl Counter for GenericCounter {
    #[inline(always)]
    fn advance(&mut self, delta: usize) {
        self.0 = self.0.strict_add(delta.try_into().unwrap())
    }

    #[inline(always)]
    fn current(&self) -> u64 {
        self.0
    }
}

pub trait Waker {
    fn wake(&mut self, times: num::NonZeroUsize);
}

impl Waker for () {
    #[inline(always)]
    fn wake(&mut self, _times: num::NonZeroUsize) {}
}

#[cfg(feature = "std")]
impl Waker for std::thread::Thread {
    #[inline(always)]
    fn wake(&mut self, _times: num::NonZeroUsize) {
        self.unpark()
    }
}

/// A counter that tracks progress through fixed-size periods.
///
/// Each time the counter advances past a multiple of it's period, a boundary
/// is considered crossed.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct PeriodicCounter<C, W> {
    counter: C,
    waker: W,
    period: num::NonZeroUsize,
}

impl<C, W> PeriodicCounter<C, W> {
    /// Creates a new counter with the given `period`.
    #[inline(always)]
    pub const fn new(period: num::NonZeroUsize, counter: C, waker: W) -> Self {
        Self {
            period,
            waker,
            counter,
        }
    }

    /// Returns the configured period (or chunk size).
    #[inline(always)]
    pub const fn period(&self) -> num::NonZeroUsize {
        self.period
    }
}

impl<C: Counter, W> PeriodicCounter<C, W> {
    /// Returns the total number of period boundaries crossed so far.
    #[inline(always)]
    pub fn boundaries_crossed(&self) -> u64 {
        self.counter.current() / num::NonZeroU64::try_from(self.period()).unwrap()
    }
}

impl<C: Counter, W: Waker> Counter for PeriodicCounter<C, W> {
    /// Advances the counter by `n` steps.
    ///
    /// Returns the number of new period boundaries crossed.
    #[inline(always)]
    fn advance(&mut self, n: usize) {
        let b = self.boundaries_crossed();

        self.counter.advance(n);

        if let Some(n) =
            num::NonZeroUsize::new(self.boundaries_crossed().strict_sub(b).try_into().unwrap())
        {
            self.waker.wake(n);
        }
    }

    #[inline(always)]
    fn current(&self) -> u64 {
        self.counter.current()
    }
}

/// Let n = `|deviation|`
/// 
/// Skips the first `n` of `it`, if `deviation` is positive.
/// 
/// Pads `it` with `n` elements generated by `pad_fn` if `deviation` is negative.
/// 
/// Leaves the iterator intact if `deviation` is zero.
fn shift_iter<I: IntoIterator>(
    it: I,
    deviation: isize,
    pad_fn: impl FnMut() -> I::Item,
) -> impl IntoIterator<Item = I::Item> {
    // notice how neither are positive at the same time
    let mut padding = 0;
    let mut skipping = 0;

    *if deviation.is_negative() {
        &mut padding
    } else {
        &mut skipping
    } = deviation.unsigned_abs();

    iter::chain(
        iter::repeat_with(pad_fn).take(padding),
        it.into_iter().skip(skipping),
    )
}

pub struct IndexedRx<C, T> {
    rx: rtrb::Consumer<T>,
    counter: C,
}

impl<C, T> IndexedRx<C, T> {
    #[inline(always)]
    pub fn new(rx: rtrb::Consumer<T>, counter: C) -> Self {
        Self { rx, counter }
    }
}

impl<C: Counter, T> IndexedRx<C, T> {
    /// Attempts to read values from the ring buffer, `idx` is used to
    /// pad with a default value (using `pad_fn`), or skip values when necessary.
    #[inline]
    pub fn recv(&mut self, idx: u64, pad_fn: impl FnMut() -> T) -> impl IntoIterator<Item = T> {
        let deviation: isize = idx
            .checked_signed_diff(self.counter.current())
            .unwrap()
            .try_into()
            .unwrap();

        let in_samples = consumer_get_all(&mut self.rx);
        let iter = ReadChunksIterWaker::new(in_samples, &mut self.counter);

        shift_iter(iter, deviation, pad_fn)
    }
}

struct ReadChunksIterWaker<'a, C: Counter, T> {
    ticker: C,
    iter: rtrb::chunks::ReadChunkIntoIter<'a, T>,
    // when the issue we raised with rtrb gets addressed we can remove this
    initial_len: usize,
}

impl<'a, C: Counter, T> ReadChunksIterWaker<'a, C, T> {
    #[inline(always)]
    fn new(chunk: rtrb::chunks::ReadChunk<'a, T>, ticker: C) -> Self {
        Self {
            initial_len: chunk.len(),
            iter: chunk.into_iter(),
            ticker,
        }
    }
}

impl<'a, C: Counter, T> Iterator for ReadChunksIterWaker<'a, C, T> {
    type Item = T;

    #[inline(always)]
    fn next(&mut self) -> Option<Self::Item> {
        self.iter.next()
    }

    #[inline(always)]
    fn size_hint(&self) -> (usize, Option<usize>) {
        self.iter.size_hint()
    }

    #[inline(always)]
    fn nth(&mut self, n: usize) -> Option<Self::Item> {
        self.iter.nth(n)
    }
}

impl<'a, C: Counter, T> ExactSizeIterator for ReadChunksIterWaker<'a, C, T> {
    #[inline(always)]
    fn len(&self) -> usize {
        self.iter.len()
    }
}

impl<'a, C: Counter, T> Drop for ReadChunksIterWaker<'a, C, T> {
    #[inline(always)]
    fn drop(&mut self) {
        self.ticker
            // sent samples = initial samples - remaining samples
            .advance(self.initial_len.strict_sub(self.iter.len()));
    }
}

pub struct IndexedTx<C, T> {
    counter: C,
    tx: rtrb::Producer<T>,
}

impl<C, T> IndexedTx<C, T> {
    #[inline(always)]
    pub const fn new(tx: rtrb::Producer<T>, counter: C) -> Self {
        Self { counter, tx }
    }
}

impl<C: Counter, T> IndexedTx<C, T> {
    /// Writes the elements in `values` into the ring buffer, `idx` is used to
    /// pad with a default value (using `pad_fn`), or skip samples when necessary.
    #[inline]
    pub fn send(
        &mut self,
        idx: u64,
        values: impl IntoIterator<Item = T>,
        pad_fn: impl FnMut() -> T,
    ) {
        let deviation: isize = self.counter.current()
            .checked_signed_diff(idx)
            .unwrap()
            .try_into()
            .unwrap();

        let out_iter = shift_iter(values, deviation, pad_fn);
        let n_pushed_samples = producer_get_all(&mut self.tx).fill_from_iter(out_iter);

        self.counter.advance(n_pushed_samples);
    }
}

/// Acquires a write chunk covering all available producer slots.
#[inline(always)]
pub fn producer_get_all<T>(tx: &mut rtrb::Producer<T>) -> rtrb::chunks::WriteChunkUninit<'_, T> {
    tx.write_chunk_uninit(tx.slots()).unwrap()
}

/// Acquires a read chunk covering all available consumer slots.
#[inline(always)]
pub fn consumer_get_all<T>(rx: &mut rtrb::Consumer<T>) -> rtrb::chunks::ReadChunk<'_, T> {
    rx.read_chunk(rx.slots()).unwrap()
}
